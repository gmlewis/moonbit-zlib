// This file is based on the Go implementation found here:
// https://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/compress/zlib/reader_test.go
// which has the copyright notice:
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

///|
typealias IOError = @io.IOError

///|
let err_header = @zlib.err_header

///|
let err_checksum = @zlib.err_checksum

///|
let err_dictionary = @zlib.err_dictionary

///|
struct ZlibTest {
  desc : String
  raw : Bytes
  compressed : Array[Int]
  dict : Array[Int]
  err : IOError?
}

// Compare-to-golden test data was generated by the ZLIB example program at
// https://www.zlib.net/zpipe.c

///|
let zlib_tests : Array[ZlibTest] = [
  {
    desc: "truncated empty",
    raw: b"",
    compressed: [],
    dict: [],
    err: Some(@io.err_unexpected_eof),
  },
  {
    desc: "truncated dict",
    raw: b"",
    compressed: [0x78, 0xbb],
    dict: [0x00],
    err: Some(@io.err_unexpected_eof),
  },
  {
    desc: "truncated checksum",
    raw: b"",
    compressed: [
      0x78, 0xbb, 0x00, 0x01, 0x00, 0x01, 0xca, 0x48, 0xcd, 0xc9, 0xc9, 0xd7, 0x51,
      0x28, 0xcf, 0x2f, 0xca, 0x49, 0x01, 0x04, 0x00, 0x00, 0xff, 0xff,
    ],
    dict: [0x00],
    err: Some(@io.err_unexpected_eof),
  },
  {
    desc: "empty",
    raw: b"",
    compressed: [0x78, 0x9c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01],
    dict: [],
    err: None,
  },
  {
    desc: "goodbye",
    raw: b"goodbye, world",
    compressed: [
      0x78, 0x9c, 0x4b, 0xcf, 0xcf, 0x4f, 0x49, 0xaa, 0x4c, 0xd5, 0x51, 0x28, 0xcf,
      0x2f, 0xca, 0x49, 0x01, 0x00, 0x28, 0xa5, 0x05, 0x5e,
    ],
    dict: [],
    err: None,
  },
  {
    desc: "bad header (CINFO)",
    raw: b"",
    compressed: [0x88, 0x98, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01],
    dict: [],
    err: Some(err_header),
  },
  {
    desc: "bad header (FCHECK)",
    raw: b"",
    compressed: [0x78, 0x9f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01],
    dict: [],
    err: Some(err_header),
  },
  {
    desc: "bad checksum",
    raw: b"",
    compressed: [0x78, 0x9c, 0x03, 0x00, 0x00, 0x00, 0x00, 0xff],
    dict: [],
    err: Some(err_checksum),
  },
  {
    desc: "not enough data",
    raw: b"",
    compressed: [0x78, 0x9c, 0x03, 0x00, 0x00, 0x00],
    dict: [],
    err: Some(@io.err_unexpected_eof),
  },
  {
    desc: "excess data is silently ignored",
    raw: b"",
    compressed: [
      0x78, 0x9c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x78, 0x9c, 0xff,
    ],
    dict: [],
    err: None,
  },
  {
    desc: "dictionary",
    raw: b"Hello, World!\n",
    compressed: [
      0x78, 0xbb, 0x1c, 0x32, 0x04, 0x27, 0xf3, 0x00, 0xb1, 0x75, 0x20, 0x1c, 0x45,
      0x2e, 0x00, 0x24, 0x12, 0x04, 0x74,
    ],
    dict: [
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x0a,
    ],
    err: None,
  },
  {
    desc: "wrong dictionary",
    raw: b"",
    compressed: [
      0x78, 0xbb, 0x1c, 0x32, 0x04, 0x27, 0xf3, 0x00, 0xb1, 0x75, 0x20, 0x1c, 0x45,
      0x2e, 0x00, 0x24, 0x12, 0x04, 0x74,
    ],
    dict: [0x48, 0x65, 0x6c, 0x6c],
    err: Some(err_dictionary),
  },
  {
    desc: "truncated zlib stream amid raw-block",
    raw: b"hello",
    compressed: [
      0x78, 0x9c, 0x00, 0x0c, 0x00, 0xf3, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
    ],
    dict: [],
    err: Some(@io.err_unexpected_eof),
  },
  {
    desc: "truncated zlib stream amid fixed-block",
    raw: b"He",
    compressed: [0x78, 0x9c, 0xf2, 0x48, 0xcd],
    dict: [],
    err: Some(@io.err_unexpected_eof),
  },
]

///|
type! TestError String derive(Show)

test "decompressor" {
  let b = @io.Buffer::new()
  for tt in zlib_tests {
    let inp = @io.Buffer::new()
    let compressed_bytes = tt.compressed.map(fn(b) { b.to_byte() })
      |> Bytes::from_array()
    guard let (_, None) = inp.write_bytes(compressed_bytes)
    let dict = @io.Slice::new(tt.dict.map(fn(b) { b.to_byte() }))
    let (zr, err) = @zlib.Reader::new_dict(inp, dict)
    if err != None {
      if err != tt.err {
        raise TestError("\{tt.desc}: @zlib.Reader::new_dict: \{err}")
      }
      continue
    }
    // defer zr.Close()

    // Read and verify correctness of data.
    b.reset()
    let (n, err) = @io.copy(b, zr)
    if err != None {
      let _ = zr.close()
      if err != tt.err {
        raise TestError("\{tt.desc}: io.copy: \{err} want \{tt.err}")
      }
      continue
    }
    let s = b.to_bytes()
    if s != tt.raw {
      let _ = zr.close()
      raise TestError(
        "\{tt.desc}: got \{n}-byte \{s.to_array()} want \{tt.raw.length()}-byte \{tt.raw.to_array()}",
      )
    }

    // Check for sticky errors.
    let (n, err) = zr.read(@io.Slice::new([0]))
    if n != 0 || err != Some(@io.eof) {
      let _ = zr.close()
      raise TestError("\{tt.desc}: read() = (\{n}, \{err}), want (0, io.EOF)")
    }
    let err = zr.close()
    if err != None {
      raise TestError("\{tt.desc}: close() = \{err}, want None")
    }
  }
}
